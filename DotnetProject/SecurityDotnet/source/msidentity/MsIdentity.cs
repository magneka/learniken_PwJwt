namespace SecurityDotnet.source;

public interface IMsIdentity
{
    string CreatePasswordHash(string password);
    bool ValidatePassword(string password, string passwordHash);
};


public class MsIdentity : IMsIdentity
{
    HashAlgorithmName[] hashAlgorithms = {
                HashAlgorithmName.SHA1,
                HashAlgorithmName.SHA256,
                HashAlgorithmName.SHA512
        };

    public string CreatePasswordHash(string password)
    {
        // Defaultverdier for Ms Identity versjon 3
        Int32 saltSize = 16;
        Int32 iterations = 10000;
        Int32 hashAlgoIndex = 1;
        HashAlgorithmName hashAlgo = hashAlgorithms[hashAlgoIndex];

        // Salt is autogenerated av rutinen, trenger bare oppgi lengden
        Rfc2898DeriveBytes pkdf = new Rfc2898DeriveBytes(
                password: password,
                saltSize: saltSize,
                iterations: iterations,
                hashAlgorithm: hashAlgo);

        // Kjør hash funksjonen og hent ut hash og salt som ble autogenert
        byte[] _hash = pkdf.GetBytes(32);
        byte[] _salt = pkdf.Salt;

        // Siden vi skal lagre en binær struktur må vi lage byte arrays
        byte[] _identityVersion = new byte[1] { 1 };
        byte[] _hashAlgoIndex = BitConverter.GetBytes(1);
        byte[] _iterations = BitConverter.GetBytes(iterations);
        byte[] _saltSize = BitConverter.GetBytes(saltSize);

        // Dotnet er LittleEndian, så i må reversere byte arrays for int32
        if (BitConverter.IsLittleEndian)
        {
            Array.Reverse(_identityVersion);
            Array.Reverse(_hashAlgoIndex);
            Array.Reverse(_iterations);
            Array.Reverse(_saltSize);
        }

        // Nå kan vi slå sammen alle byte arrays til en byte array
        byte[] byteResult = _identityVersion
            .Concat(_hashAlgoIndex)
            .Concat(_iterations)
            .Concat(_saltSize)
            .Concat(_salt)
            .Concat(_hash)
            .ToArray();

        // Så lager koder vi strengen til en Base64, som kan lagres i databasen
        string passwordHash = Convert.ToBase64String(byteResult);

        return passwordHash;
    }


    public bool ValidatePassword(string password, string passwordHash)
    {


        // Konverter strengen fra databasen, passwordHash til en byte array
        byte[] data = Convert.FromBase64String(passwordHash);

        // Vi trenger byte arrays til å lagre data i..
        byte[] _identityVersion = new byte[1];
        byte[] _hashAlgoIndex = new byte[4];
        byte[] _iterations = new byte[4];
        byte[] _saltSize = new byte[4];
        byte[] _saltString = new byte[16];
        byte[] _hashedPassword = new byte[32];

        // La oss plukke ut hexverdiene fra identityhashen
        Buffer.BlockCopy(data, 0, _identityVersion, 0, 1);  // 1st byte - identityversjon
        Buffer.BlockCopy(data, 1, _hashAlgoIndex, 0, 4);    // 2nd to 5th byte - hashalg
        Buffer.BlockCopy(data, 5, _iterations, 0, 4);       // 6th to 9th byte - kostnad/iterasjoner
        Buffer.BlockCopy(data, 9, _saltSize, 0, 4);         // 10th to 13th - salt lengde
        Buffer.BlockCopy(data, 13, _saltString, 0, 16);     //14th to 29th - salt strengen
        Buffer.BlockCopy(data, 29, _hashedPassword, 0, 32); // 30th to 61th - resultat fra hashfunksjonen

        // Siden dotnet er LittleEndian, må vi reversere byte arrays før vi kan konvertere til Int typer
        if (BitConverter.IsLittleEndian)
        {
            Array.Reverse(_identityVersion);
            Array.Reverse(_hashAlgoIndex);
            Array.Reverse(_iterations);
        }

        // Vi skal ha identityversjon 1
        byte identityVersion = _identityVersion[0];
        if (identityVersion != 1)
            return false;

        // Gjør oppslag på hashalgoritmen (sha256)
        int hashAlgoIndex = BitConverter.ToInt32(_hashAlgoIndex, 0);
        HashAlgorithmName hashAlgo = hashAlgorithms[hashAlgoIndex];

        int iterations = BitConverter.ToInt32(_iterations, 0);

        Rfc2898DeriveBytes pbkdf2 = new Rfc2898DeriveBytes(
                password: password,
                salt: _saltString,
                iterations: iterations,
                hashAlgorithm: hashAlgo);

        // Kjør hash iterations antall ganger
        byte[] _hash = pbkdf2.GetBytes(32);

        // Converter til strenger input og output, lettere å sammenligne strenger enn byte arrays
        string orgHash = Convert.ToHexString(_hashedPassword);
        string checkHash = Convert.ToHexString(_hash);

        // Er passordet korrekt?
        return (orgHash == checkHash);

    }
}